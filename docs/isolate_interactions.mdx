---
id: isolate_interactions
title: Isolate your page transitions and animations
description: TBD
---
import interactions_app_1 from './assets/interactions_app_1.gif';
import monarch_and_interactions from './assets/monarch_and_interactions.gif';

When building apps with multiple screens, it is essential to make the transitions between them appear 
seamless rather than abrupt. To achieve that, standard practice is to use transition animations(e.g., 
fade in, slide in, etc.) when navigating between screens. But how do we test these interactions in a 
simple yet scalable manner? Isolation.

### Isolating interactions

To efficiently test interactions in your app, it would be ideal to test them independently. Isolating your 
interactions allows you to decouple and test with them without depending on the rest of your app or backend. 
In addition, when you isolate your interactions, 
you can easily set them up to be in the specific state you want to test them in.

### Setup

Interactions and animations exist between two visual states. For instance, when navigating between two screens, 
the animated transition exists between the origin and destination pages.

To demonstrate this, let's use the below expense list screen that transitions to a details page when you tap 
one of the list items.

<div className="docs-intro">
  <img className="docs-screenshot macos" alt="interactions app screenshot" src={interactions_app_1} width="240px"/>
</div>


First, let's set up a left-to-right slide-in animated transition using  `PageRouteBuilder` class.
```dart
Route createAnimatedRoute({required Widget screen}) {
    return PageRouteBuilder(
        pageBuilder: (context, animation, secondaryAnimation) => screen,
        transitionsBuilder: (context, animation, secondaryAnimation, child) {
          const begin = Offset(1.0, 0.0);
          const end = Offset.zero;
          const curve = Curves.ease;
          final tween = Tween(begin: begin, end: end).chain(CurveTween(curve: curve));

          return SlideTransition(
              position: animation.drive(tween), child: child);
        });
}
```
Then in the `ExpenseListScreen` we pass the animated route to the `Navigator` in the list item's `onTap()` method. 
You can find the complete code [here](https://gist.github.com/mijiga/a6157a3590055534726f642a5ab83c34).
```dart
/* ExpenseListScreen */

ListView.builder(
      itemCount: _expenses.length,
      itemBuilder: (BuildContext context, int index) {
        var expense = _expenses[index];
        return GestureDetector(
          child: ExpenseCard(expense: expense),
          onTap: () {
            Route route = _createAnimatedRoute(screen: const DetailsScreen());
            Navigator.of(context).push(route);
          },
        );
      })
```
### Writing stories for interactions

The interaction demonstrated above follows the order:

- User taps a list item
- Animated transition is initiated
- Details page is displayed

With that in mind, when writing a story for an interaction, you should target your story toward the widget that triggers it.
 In this case, the `ListView` widget in the `ExpenseListScreen`. An appropriate story for the example above would therefore 
 look like the one below. More on how to setup stories [here](write-first-story).
```dart
Widget displayList() => ExpenseListScreen(expenses: [
    Expense(title: "Dinner", date: "May 30", amount: 50),
    Expense(title: "Lunch", date: "May 29", amount: 30),
    Expense(title: "Shopping", date: "May 26", amount: 75),
    Expense(title: "Groceries", date: "May 22", amount: 99),
]);
```
After running `monarch run` in the CLI, you should be able to test your interaction in isolation like below:
<div className="docs-intro">
  <img className="docs-screenshot macos" alt="screenshot of monarch gui on interactions app" width="800px" src={monarch_and_interactions} />
</div>

### Leveraging Monarch in your project

With all of your app's interaction stories laid out in the Monarch app, you can directly reach the widgets and interactions you 
want to test or debug without having to navigate through multiple screens first. As a result, you can then test and debug your 
app's interactions in a simple and scalable manner.
